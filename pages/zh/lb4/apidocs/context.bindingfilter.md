---
lang: en
title: 'API docs: context.bindingfilter'
keywords: LoopBack 4.0, LoopBack 4
sidebar: lb4_sidebar
permalink: /doc/en/lb4/apidocs.context.bindingfilter.html
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@loopback/context](./context.md) &gt; [BindingFilter](./context.bindingfilter.md)

## BindingFilter type

A function that filters bindings. It returns `true` to select a given binding.

<b>Signature:</b>

```typescript
export declare type BindingFilter<ValueType = unknown> = (binding: Readonly<Binding<unknown>>) => boolean;
```

## Remarks

TODO(semver-major): We might change this type in the future to either remove the `<ValueType>` or make it as type guard by asserting the matched binding to be typed with `<ValueType>`<!-- -->.

\*\*NOTE\*\*: Originally, we allow filters to be tied with a single value type. This actually does not make much sense - the filter function is typically invoked on all bindings to find those ones matching the given criteria. Filters must be prepared to handle bindings of any value type. We learned about this problem after enabling TypeScript's `strictFunctionTypes` check, but decided to preserve `ValueType` argument for backwards compatibility. The `<ValueType>` represents the value type for matched bindings but it's not used for checking.

Ideally, `BindingFilter` should be declared as a type guard as follows:

```ts
export type BindingFilterGuard<ValueType = unknown> = (
  binding: Readonly<Binding<unknown>>,
) => binding is Readonly<Binding<ValueType>>;

```
But TypeScript treats the following types as incompatible and does not accept type 1 for type 2.

1. `(binding: Readonly<Binding<unknown>>) => boolean` 2. `(binding: Readonly<Binding<unknown>>) => binding is Readonly<Binding<ValueType>>`


