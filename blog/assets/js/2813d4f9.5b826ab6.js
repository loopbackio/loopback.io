"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[7383],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=i,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||a;return n?r.createElement(m,o(o({ref:t},p),{},{components:n})):r.createElement(m,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9964:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return p},toc:function(){return u},default:function(){return h}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),o=["components"],s={title:"Building an Online Game With LoopBack 4 - User Authentication and Role-Based Access Control (Part 4)",date:new Date("2019-06-26T00:00:00.000Z"),authors:"wenbo",slug:"building-an-online-game-with-loopback-4-pt4",tags:["how-to"]},l=void 0,c={permalink:"/blog/building-an-online-game-with-loopback-4-pt4",editUrl:"https://github.com/loopbackio/loopback-blog/blog/2019/2019-06-26-building-an-online-game-with-loopback-4-pt4.md",source:"@site/blog/2019/2019-06-26-building-an-online-game-with-loopback-4-pt4.md",title:"Building an Online Game With LoopBack 4 - User Authentication and Role-Based Access Control (Part 4)",description:"Originally published on strongloop.com",date:"2019-06-26T00:00:00.000Z",formattedDate:"June 26, 2019",tags:[{label:"how-to",permalink:"/blog/tags/how-to"}],readingTime:15.795,truncated:!0,authors:[{name:"Wen Bo",title:"LoopBack Maintainer",url:"https://github.com/gobackhuoxing",imageURL:"https://avatars.githubusercontent.com/u/22156589",key:"wenbo"}],frontMatter:{title:"Building an Online Game With LoopBack 4 - User Authentication and Role-Based Access Control (Part 4)",date:"2019-06-26T00:00:00.000Z",authors:"wenbo",slug:"building-an-online-game-with-loopback-4-pt4",tags:["how-to"]},prevItem:{title:"What's New in LoopBack 4 Authentication 2.0",permalink:"/blog/loopback-4-authentication-updates"},nextItem:{title:"Migrating from LoopBack 3 to LoopBack 4",permalink:"/blog/migrate-from-loopback-3-to-loopback-4"}},p={authorsImageUrls:[void 0]},u=[{value:"Part 4: User Authentication and Role-Based Access Control",id:"part-4-user-authentication-and-role-based-access-control",children:[{value:"In This Episode",id:"in-this-episode",children:[],level:3},{value:"Introduction",id:"introduction",children:[],level:3},{value:"Previously on Building an Online Game With LoopBack 4",id:"previously-on-building-an-online-game-with-loopback-4",children:[],level:3},{value:"Basic Structure",id:"basic-structure",children:[{value:"LoopBack Authentication Package",id:"loopback-authentication-package",children:[],level:4},{value:"Self-defined Authorization",id:"self-defined-authorization",children:[],level:4},{value:"<code>application.ts</code>, <code>sequence.ts</code> and <code>controller</code>",id:"applicationts-sequencets-and-controller",children:[],level:4}],level:3},{value:"Install <code>@loopback/authentication</code>",id:"install-loopbackauthentication",children:[],level:3},{value:"Refactor Model",id:"refactor-model",children:[],level:3},{value:"Self-Defined Authorization Component",id:"self-defined-authorization-component",children:[{value:"Users Permissions",id:"users-permissions",children:[],level:4},{value:"Interfaces and Types",id:"interfaces-and-types",children:[],level:4},{value:"Binding Self-Defined Authorization Component",id:"binding-self-defined-authorization-component",children:[],level:4},{value:"Providers",id:"providers",children:[],level:4},{value:"Strategies",id:"strategies",children:[],level:4},{value:"Interceptor",id:"interceptor",children:[],level:4},{value:"Services",id:"services",children:[],level:4}],level:3},{value:"Putting Everything Together",id:"putting-everything-together",children:[{value:"Binding all the Pieces in <code>application.ts</code>",id:"binding-all-the-pieces-in-applicationts",children:[],level:4},{value:"Specifying the Authentication Action in <code>sequence.ts</code>",id:"specifying-the-authentication-action-in-sequencets",children:[],level:4}],level:3},{value:"Authenticate APIs",id:"authenticate-apis",children:[{value:"CharacterController",id:"charactercontroller",children:[],level:4},{value:"AdminController",id:"admincontroller",children:[],level:4}],level:3},{value:"Applying This to Your Own Project",id:"applying-this-to-your-own-project",children:[],level:3},{value:"What&#39;s Next?",id:"whats-next",children:[],level:3}],level:2}],d={toc:u};function h(e){var t=e.components,s=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Originally published on ",(0,a.kt)("a",{parentName:"em",href:"https://strongloop.com"},"strongloop.com"))),(0,a.kt)("h2",{id:"part-4-user-authentication-and-role-based-access-control"},"Part 4: User Authentication and Role-Based Access Control"),(0,a.kt)("h3",{id:"in-this-episode"},"In This Episode"),(0,a.kt)("p",null,"We already have some APIs that allow users to customize their characters. However, a user should not get access to characters that belong to other users. With that in mind, we will add user authentication and role-based access control to this project."),(0,a.kt)("p",null,"You can check ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gobackhuoxing/first-web-game-lb4/tree/part4/firstgame"},"here")," for this episode's code."),(0,a.kt)("h3",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"In this series, I\u2019m going to help you learn LoopBack 4 and how to use it to easily build your own API and web project. We\u2019ll create a new project I\u2019ve been working on: an online web text-based adventure game. In this game, you can create your own account to build characters, fight monsters and find treasures. You will be able to control your character to take a variety of actions: attacking enemies, casting spells, and getting loot. This game also allows multiple players to log in and play with their friends."),(0,a.kt)("h3",{id:"previously-on-building-an-online-game-with-loopback-4"},"Previously on Building an Online Game With LoopBack 4"),(0,a.kt)("p",null,"In the last episode, we created customized APIs to manage ",(0,a.kt)("inlineCode",{parentName:"p"},"weapon"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"armor"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"skill")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"character"),"."),(0,a.kt)("p",null,"Here are the previous episodes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://strongloop.com/strongblog/building-online-game-with-loopback-4-pt1/"},"Part 1: Building a Simple LoopBack Project With MongoDB")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://strongloop.com/strongblog/building-an-online-game-with-loopback-4-pt2/"},"Part 2: Generating Universally Unique ID and Managing Models Relationships")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://strongloop.com/strongblog/building-an-online-game-with-loopback-4-pt3/"},"Part 3: Customizing APIs in Controller"))),(0,a.kt)("h3",{id:"basic-structure"},"Basic Structure"),(0,a.kt)("p",null,"LoopBack 4 provides us a built-in authentication package. This package includes an authentication system as the skeleton to verify the identity of a request. It invokes an authentication strategy provided by the developer to process the authentication information in the request and to then return the corresponding user profile."),(0,a.kt)("p",null,"In this episode, I will combine LoopBack authentication package with my self-defined authorization. This diagram shows the basic structure:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"structure",src:n(4323).Z,width:"2688",height:"1272"})),(0,a.kt)("h4",{id:"loopback-authentication-package"},"LoopBack Authentication Package"),(0,a.kt)("p",null,"The one in the middle is the ",(0,a.kt)("inlineCode",{parentName:"p"},"@loopback/authentication")," package. It has three main components:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Providers:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"AuthMetadataProvider: this reads the decorator metadata from the controller methods wherever the ",(0,a.kt)("inlineCode",{parentName:"li"},"@authenticate")," decorator is used."),(0,a.kt)("li",{parentName:"ul"},"AuthenticateActionProvider: this provides the authentication action which uses AuthenticationStrategyProvider to obtain a registered authentication strategy (if one exists), calls the authenticate(request) method of the given authentication strategy, and places the user profile on the request context."),(0,a.kt)("li",{parentName:"ul"},"AuthenticationStrategyProvider: this is the extension point for you to add your own authentication strategies. I will show you how to do that later. It also has the job of finding a strategy of a given name (if existed), and returning it to AuthenticateActionProvider."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Services: all services in this package are interfaces. You can create your own services as well."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"TokenService: an interface for generating and verifying an authentication token."),(0,a.kt)("li",{parentName:"ul"},"UserService: an interface for performing the login action in an authentication strategy, and for converting a User object into a UserProfile object. To keep this project as simple as possible, I am not going to use this interface. I will integrate this to the TokenService."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Decorators: ",(0,a.kt)("inlineCode",{parentName:"p"},"@authenticate"),". Annotate the APIs that need authentication with this decorator."))),(0,a.kt)("h4",{id:"self-defined-authorization"},"Self-defined Authorization"),(0,a.kt)("p",null,"The one in the bottom left is our self-defined authorization. It has three components:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Providers:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"UserPermissionsProvider: this will check user's permission. We will create different user permissions for different users. This provider will be invoked in AuthorizationInterceptor."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Strategies: this is where we add our own authentication strategies."),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"JWTStrategy: we are going to create a custom authentication strategy based on ",(0,a.kt)("a",{parentName:"li",href:"https://jwt.io/"},"JSON Web Token"),"."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Services:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"JWTService: a service associate with JWTStrategy to generate and verify JWT."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Interceptors:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"AuthorizationInterceptor: a middle layer comes after authentication that use UserPermissionsProvider to verify user's permission. You can find more information about LoopBack 4 Interceptor at ",(0,a.kt)("a",{parentName:"li",href:"https://loopback.io/doc/en/lb4/Interceptors.html#order-of-invocation-for-interceptors"},"here"),".")))),(0,a.kt)("p",null,"Here is a diagram to show you what will happen after an API call."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"structure",src:n(6573).Z,width:"2960",height:"1414"})),(0,a.kt)("h4",{id:"applicationts-sequencets-and-controller"},(0,a.kt)("inlineCode",{parentName:"h4"},"application.ts"),", ",(0,a.kt)("inlineCode",{parentName:"h4"},"sequence.ts")," and ",(0,a.kt)("inlineCode",{parentName:"h4"},"controller")),(0,a.kt)("p",null,"In order to use the all of above in our project, we have three more steps to complete:   "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Bind everything in ",(0,a.kt)("inlineCode",{parentName:"li"},"application.ts"),". ",(0,a.kt)("inlineCode",{parentName:"li"},"application.ts")," is like the main function of LoopBack project."),(0,a.kt)("li",{parentName:"ul"},"Add authenticate action into ",(0,a.kt)("inlineCode",{parentName:"li"},"sequence.ts"),". A sequence contains a list of actions that is performed for each request."),(0,a.kt)("li",{parentName:"ul"},"Put ",(0,a.kt)("inlineCode",{parentName:"li"},"@authenticate")," decorator above your APIs.")),(0,a.kt)("p",null,"You can check ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/strongloop/loopback-next/blob/master/packages/authentication/docs/authentication-system.md"},"this tutorial")," or ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/strongloop/loopback4-example-shopping"},"this shopping example")," for more information of LoopBack 4 Authentication package."),(0,a.kt)("h3",{id:"install-loopbackauthentication"},"Install ",(0,a.kt)("inlineCode",{parentName:"h3"},"@loopback/authentication")),(0,a.kt)("p",null,"Simply run ",(0,a.kt)("inlineCode",{parentName:"p"},"npm install --save @loopback/authentication@latest")," in your project root."),(0,a.kt)("p",null,"Reminder: We are using ",(0,a.kt)("inlineCode",{parentName:"p"},"@loopback/authentication@2.1.0")," in this project. If you want to use other versions, you may need to change you code accordingly. You may also need to run ",(0,a.kt)("inlineCode",{parentName:"p"},"npm outdated")," in your project root to see if other LoopBack packages need update."),(0,a.kt)("h3",{id:"refactor-model"},"Refactor Model"),(0,a.kt)("p",null,"In previous episodes, we used UUIDs as our ",(0,a.kt)("inlineCode",{parentName:"p"},"character")," IDs. But UUIDs are 36 digits string IDs. We can not let user use UUIDs to login. So we will use email instead of UUID."),(0,a.kt)("p",null,"To keep this project as simple as possible, a user can only own one character. So user and character are basically the same thing. ",(0,a.kt)("inlineCode",{parentName:"p"},"character")," model holds all user information."),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"src/controllers/character.models"),", remove id and add email and password properties."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@property({\n  type: 'string',\n  id: true,\n  required: true,\n})\nemail?: string;\n\n@property({\n  type: 'string',\n  required: true,\n})\npassword: string;\n")),(0,a.kt)("p",null,"Besides, we need to add user permission to ",(0,a.kt)("inlineCode",{parentName:"p"},"character")," model."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {PermissionKey} from '../authorization';\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@property.array(String)\npermissions: PermissionKey[];\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"permissions")," is an array of ",(0,a.kt)("inlineCode",{parentName:"p"},"PermissionKey"),"s. We will create ",(0,a.kt)("inlineCode",{parentName:"p"},"PermissionKey")," later."),(0,a.kt)("h3",{id:"self-defined-authorization-component"},"Self-Defined Authorization Component"),(0,a.kt)("p",null,"First, let's create a folder 'authorization' in ",(0,a.kt)("inlineCode",{parentName:"p"},"src")," to hold everything in this episode. This will be our self-defined authorization package."),(0,a.kt)("p",null,"I will show you how to create everything step by step. You can also check ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gobackhuoxing/first-web-game-lb4/tree/part4/firstgame/src/authorization"},"here")," for my ",(0,a.kt)("inlineCode",{parentName:"p"},"authorization")," folder."),(0,a.kt)("h4",{id:"users-permissions"},"Users Permissions"),(0,a.kt)("p",null,"Let's create permissions for users. An API may have one or more required permissions. Users need to have all of the required permissions to access that API."),(0,a.kt)("p",null,"Create ",(0,a.kt)("inlineCode",{parentName:"p"},"permission-key.ts")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"src/authorization"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export const enum PermissionKey {\n  // For accessing own (logged in user) profile\n  ViewOwnUser = 'ViewOwnUser',\n  // For creating a user\n  CreateUser = 'CreateUser',\n  // For updating own (logged in user) profile\n  UpdateOwnUser = 'UpdateOwnUser',\n  // For deleting a user\n  DeleteOwnUser = 'DeleteOwnUser',\n\n  //admin\n  // For updating other users profile\n  UpdateAnyUser = 'UpdateAnyUser',\n  // For accessing other users profile.\n  ViewAnyUser = 'ViewAnyUser',\n  // For deleting a user\n  DeleteAnyUser = 'DeleteAnyUser',\n}\n")),(0,a.kt)("p",null,"This file holds all permissions. ",(0,a.kt)("inlineCode",{parentName:"p"},"ViewOwnUser"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"CreateUser"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateOwnUser"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"DeleteOwnUser")," are for regular users. ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateAnyUser"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ViewAnyUser"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"DeleteAnyUser")," are for admins only."),(0,a.kt)("h4",{id:"interfaces-and-types"},"Interfaces and Types"),(0,a.kt)("p",null,"To make it easier to import, we will put all of useful interfaces, types, and schemas together."),(0,a.kt)("p",null,"Create ",(0,a.kt)("inlineCode",{parentName:"p"},"types.ts")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"src/authorization"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {PermissionKey} from './permission-key';\n\nexport interface UserPermissionsFn {\n  (\n    userPermissions: PermissionKey[],\n    requiredPermissions: RequiredPermissions,\n  ): boolean;\n}\n\nexport interface MyUserProfile  {\n  id: string;\n  email: string;\n  name: string;\n  permissions: PermissionKey[];\n}\n\nexport interface RequiredPermissions {\n  required: PermissionKey[];\n}\n\nexport const UserProfileSchema = {\n  type: 'object',\n  required: ['email', 'password', 'name'],\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email',\n    },\n    password: {\n      type: 'string',\n      minLength: 8,\n    },\n    name: {type: 'string'},\n  },\n};\n\nexport const UserRequestBody = {\n  description: 'The input of create user function',\n  required: true,\n  content: {\n    'application/json': {schema: UserProfileSchema},\n  },\n};\n\nexport interface Credential  {\n  email: string;\n  password: string;\n  permissions: PermissionKey[];\n}\n\nexport const CredentialsSchema = {\n  type: 'object',\n  required: ['email', 'password'],\n  properties: {\n    email: {\n      type: 'string',\n      format: 'email',\n    },\n    password: {\n      type: 'string',\n      minLength: 8,\n    },\n  },\n};\n\nexport const CredentialsRequestBody = {\n  description: 'The input of login function',\n  required: true,\n  content: {\n    'application/json': {schema: CredentialsSchema},\n  },\n};\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"MyUserProfile")," is the format of our user profile. It is the information needed to perform authentication and authorization."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"UserProfileSchema")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"CredentialsSchema")," are the formats of request input. We use them to validate request input in ",(0,a.kt)("inlineCode",{parentName:"p"},"controller"),"."),(0,a.kt)("h4",{id:"binding-self-defined-authorization-component"},"Binding Self-Defined Authorization Component"),(0,a.kt)("p",null,"Create ",(0,a.kt)("inlineCode",{parentName:"p"},"keys.ts")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"src/authorization"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"MyAuthBindings")," is the self-defined component that we need to bind to ",(0,a.kt)("inlineCode",{parentName:"p"},"application.ts"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"TokenServiceConstants")," is the value we will use later in token service."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {BindingKey} from '@loopback/context';\nimport {UserPermissionsFn} from './types';\nimport {TokenService} from '@loopback/authentication';\n/**\n * Binding keys used by this component.\n */\nexport namespace MyAuthBindings {\n  export const USER_PERMISSIONS = BindingKey.create<UserPermissionsFn>(\n    'userAuthorization.actions.userPermissions',\n  );\n\n  export const TOKEN_SERVICE = BindingKey.create<TokenService>(\n    'services.authentication.jwt.tokenservice',\n  );\n}\n\nexport namespace TokenServiceConstants {\n  export const TOKEN_SECRET_VALUE = 'myjwts3cr3t';\n  export const TOKEN_EXPIRES_IN_VALUE = '600';\n}\n")),(0,a.kt)("h4",{id:"providers"},"Providers"),(0,a.kt)("p",null,"The LoopBack authorization package gives us three providers for authorization: strategies, action, and metadata. We need to customize our own provider for users permissions."),(0,a.kt)("p",null,"Create folder ",(0,a.kt)("inlineCode",{parentName:"p"},"providers")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"src"),", then inside ",(0,a.kt)("inlineCode",{parentName:"p"},"providers"),", create ",(0,a.kt)("inlineCode",{parentName:"p"},"user-permissions.provider.ts"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {Provider} from '@loopback/context';\nimport {PermissionKey} from '../permission-key';\nimport {UserPermissionsFn, RequiredPermissions} from '../types';\nimport {intersection} from 'lodash';\n\nexport class UserPermissionsProvider implements Provider<UserPermissionsFn> {\n  constructor() {}\n\n  value(): UserPermissionsFn {\n    return (userPermissions, requiredPermissions) =>\n      this.action(userPermissions, requiredPermissions);\n  }\n\n  action(\n    userPermissions: PermissionKey[],\n    requiredPermissions: RequiredPermissions,\n  ): boolean {\n    return intersection(userPermissions, requiredPermissions.required).length\n      === requiredPermissions.required.length;\n  }\n}\n")),(0,a.kt)("p",null,"It will compare a user's permissions and required permissions, and allow the user to get access if and only if this user has all of the required permissions."),(0,a.kt)("h4",{id:"strategies"},"Strategies"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthenticationStrategyProvider")," can find a registered strategy by its name. We will create our own custom authentication strategy and then specify its name in the ",(0,a.kt)("inlineCode",{parentName:"p"},"@authenticate")," decorator. It will based on the ",(0,a.kt)("a",{parentName:"p",href:"https://jwt.io/"},"JSON Web Token"),"."),(0,a.kt)("p",null,"First, run ",(0,a.kt)("inlineCode",{parentName:"p"},"npm install jsonwebtoken --save")," in your project root to install the JWT package."),(0,a.kt)("p",null,"Create a folder ",(0,a.kt)("inlineCode",{parentName:"p"},"strategies")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"src/authorization"),". Then inside ",(0,a.kt)("inlineCode",{parentName:"p"},"strategies"),", create a file named ",(0,a.kt)("inlineCode",{parentName:"p"},"JWT.strategy.ts"),". This is our custom authentication strategy."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {Request, HttpErrors} from '@loopback/rest';\nimport {inject} from '@loopback/core';\nimport {AuthenticationStrategy,\n        AuthenticationMetadata,\n        AuthenticationBindings,\n        TokenService,\n} from '@loopback/authentication';\nimport {MyUserProfile,\n        UserPermissionsFn,\n        RequiredPermissions,} from '../types';\nimport {MyAuthBindings,} from '../keys';\n\nexport class JWTStrategy implements AuthenticationStrategy{\n  name: string = 'jwt';\n\n  constructor(\n    @inject(AuthenticationBindings.METADATA)\n    public metadata: AuthenticationMetadata,\n    @inject(MyAuthBindings.USER_PERMISSIONS)\n    protected checkPermissons: UserPermissionsFn,\n    @inject(MyAuthBindings.TOKEN_SERVICE)\n    protected tokenService: TokenService,\n  ) {}\n  async authenticate(request: Request): Promise<MyUserProfile | undefined> {\n    const token: string = this.extractCredentials(request);\n    try{\n      const user: MyUserProfile = await this.tokenService.verifyToken(token) as MyUserProfile;\n      return user;\n    } catch (err) {\n      Object.assign(err, {code: 'INVALID_ACCESS_TOKEN', statusCode: 401,});\n      throw err;\n    }\n  }\n\n  extractCredentials(request: Request): string {\n    if (!request.headers.authorization) {\n      throw new HttpErrors.Unauthorized(`Authorization header not found.`);\n    }\n    const authHeaderValue = request.headers.authorization;\n\n    if (!authHeaderValue.startsWith('Bearer')) {\n      throw new HttpErrors.Unauthorized(\n        `Authorization header is not of type 'Bearer'.`,\n      );\n    }\n    const parts = authHeaderValue.split(' ');\n    if (parts.length !== 2)\n      throw new HttpErrors.Unauthorized(\n        `Authorization header value has too many parts. It must follow the pattern: 'Bearer xx.yy.zz' where xx.yy.zz is a valid JWT token.`,\n      );\n      const token = parts[1];\n      return token;\n  }\n}\n")),(0,a.kt)("p",null,"You can even use multiple strategies in one project, if needed."),(0,a.kt)("h4",{id:"interceptor"},"Interceptor"),(0,a.kt)("p",null,"Interceptor is a middle layer comes after authentication. After the authentication strategy verified user's access token, interceptor will verify use's permission."),(0,a.kt)("p",null,"Run ",(0,a.kt)("inlineCode",{parentName:"p"},"lb4 interceptor")," in your project root."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"? Interceptor name: authorize\n? Is it a global interceptor? Yes\n? Global interceptors are sorted by the order of an array of group names bound to ContextBindings.GLOBAL_INTERCEPTOR_ORDERED_GROUPS. See https://loopback.io/doc/en/lb4/Interceptors.html#order-of-invocation-for-interceptors.\nGroup name for the global interceptor: ('')\n   create src/interceptors/authorize.interceptor.ts\n   update src/interceptors/index.ts\n\nInterceptor authorize was created in src/interceptors/\n")),(0,a.kt)("p",null,"Then change ",(0,a.kt)("inlineCode",{parentName:"p"},"src/interceptors/authorize.interceptor.ts")," to this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {\n  inject,\n  globalInterceptor,\n  Interceptor,\n  InvocationContext,\n  InvocationResult,\n  Provider,\n  ValueOrPromise,\n} from '@loopback/context';\nimport {Getter} from '@loopback/core';\nimport {HttpErrors} from '@loopback/rest';\nimport {MyUserProfile,\n        MyAuthBindings,\n        UserPermissionsFn,\n        RequiredPermissions,} from '../authorization';\nimport {AuthenticationMetadata,AuthenticationBindings} from '@loopback/authentication';\n\n\n/**\n * This class will be bound to the application as an `Interceptor` during\n * `boot`\n */\n@globalInterceptor('', {tags: {name: 'authorize'}})\nexport class AuthorizationInterceptor implements Provider<Interceptor> {\n  constructor(\n    @inject(AuthenticationBindings.METADATA)\n    public metadata: AuthenticationMetadata,\n    @inject(MyAuthBindings.USER_PERMISSIONS)\n    protected checkPermissons: UserPermissionsFn,\n    @inject.getter(AuthenticationBindings.CURRENT_USER)\n    public getCurrentUser: Getter<MyUserProfile>,\n  ) {}\n\n  /**\n   * This method is used by LoopBack context to produce an interceptor function\n   * for the binding.\n   *\n   * @returns An interceptor function\n   */\n  value() {\n    return this.intercept.bind(this);\n  }\n\n  /**\n   * The logic to intercept an invocation\n   * @param invocationCtx - Invocation context\n   * @param next - A function to invoke next interceptor or the target method\n   */\n  async intercept(\n    invocationCtx: InvocationContext,\n    next: () => ValueOrPromise<InvocationResult>,\n  ) {\n    if (!this.metadata) return await next();\n\n    const result = await next();\n\n    const requiredPermissions = this.metadata.options as RequiredPermissions;\n    const user = await this.getCurrentUser();\n    if(!this.checkPermissons(user.permissions, requiredPermissions)){\n      throw new HttpErrors.Forbidden('INVALID_ACCESS_PERMISSION');\n    }\n    return result;\n  }\n}\n")),(0,a.kt)("p",null,"A global interceptor will be automatically applied to all methods in controllers."),(0,a.kt)("h4",{id:"services"},"Services"),(0,a.kt)("p",null,"Create a folder ",(0,a.kt)("inlineCode",{parentName:"p"},"services")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"src/authorization"),", then inside ",(0,a.kt)("inlineCode",{parentName:"p"},"services"),", create a file named ",(0,a.kt)("inlineCode",{parentName:"p"},"JWT.service.ts"),". This is a service that generates and verifies JWT tokens, and will be used by JWTStrategy."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {inject} from '@loopback/context';\nimport {HttpErrors} from '@loopback/rest';\nimport {promisify} from 'util';\nimport {TokenService} from '@loopback/authentication';\nimport {TokenServiceConstants} from '../keys';\nimport {MyUserProfile, Credential} from '../types';\nimport {repository} from '@loopback/repository';\nimport {CharacterRepository} from '../../repositories';\nimport * as _ from 'lodash';\nimport {toJSON} from '@loopback/testlab';\n\nconst jwt = require('jsonwebtoken');\nconst signAsync = promisify(jwt.sign);\nconst verifyAsync = promisify(jwt.verify);\n\nexport class JWTService implements TokenService {\n  constructor(\n    @repository(CharacterRepository)\n    public characterRepository: CharacterRepository,\n  ) {}\n\n  async verifyToken(token: string): Promise<MyUserProfile> {\n    if (!token) {\n      throw new HttpErrors.Unauthorized(\n        `Error verifying token : 'token' is null`,\n      );\n    }\n\n    const decryptedToken = await verifyAsync(token, TokenServiceConstants.TOKEN_SECRET_VALUE);\n    let userProfile = _.pick(decryptedToken, ['id', 'email', 'name', `permissions`]);\n    return userProfile;\n  }\n\n  async generateToken(userProfile: MyUserProfile): Promise<string> {\n    const token = await signAsync(userProfile, TokenServiceConstants.TOKEN_SECRET_VALUE, {\n      expiresIn: TokenServiceConstants.TOKEN_EXPIRES_IN_VALUE,\n    });\n\n    return token;\n  }\n\n  async getToken(credential: Credential): Promise<string> {\n    const foundUser = await this.characterRepository.findOne({\n      where: {email: credential.email},\n    });\n    if (!foundUser) {\n      throw new HttpErrors['NotFound'](\n        `User with email ${credential.email} not found.`,\n      );\n    }\n\n    if (credential.password != foundUser.password) {\n      throw new HttpErrors.Unauthorized('The credentials are not correct.');\n    }\n    const currentUser: MyUserProfile = _.pick(toJSON(foundUser), ['email', 'name', 'permissions']) as MyUserProfile;\n    const token = await this.generateToken(currentUser);\n    return token;\n  }\n}\n")),(0,a.kt)("p",null,"You can also create your own authentication services, like Hash Password service in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/strongloop/loopback4-example-shopping/blob/master/packages/shopping/src/services/hash.password.bcryptjs.ts"},"the shopping example"),"."),(0,a.kt)("h3",{id:"putting-everything-together"},"Putting Everything Together"),(0,a.kt)("h4",{id:"binding-all-the-pieces-in-applicationts"},"Binding all the Pieces in ",(0,a.kt)("inlineCode",{parentName:"h4"},"application.ts")),(0,a.kt)("p",null,"Open ",(0,a.kt)("inlineCode",{parentName:"p"},"src/application.ts"),", and add the following imports."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {asGlobalInterceptor} from '@loopback/context';\nimport {MyAuthBindings,\n        JWTService,\n        JWTStrategy,\n        UserPermissionsProvider\n} from './authorization';\nimport {AuthorizationInterceptor} from './interceptors';\nimport {AuthenticationComponent,\n       registerAuthenticationStrategy,\n} from '@loopback/authentication';\n")),(0,a.kt)("p",null,"Then, add the following lines in the constructor."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"constructor(options: ApplicationConfig = {}) {\n  super(options);\n  //add\n  // Bind authentication component related elements\n  this.component(AuthenticationComponent);\n\n  // Bind JWT & permission authentication strategy related elements\n  registerAuthenticationStrategy(this, JWTStrategy);\n  this.bind(MyAuthBindings.TOKEN_SERVICE).toClass(JWTService);\n  this.bind(MyAuthBindings.USER_PERMISSIONS).toProvider(UserPermissionsProvider);\n")),(0,a.kt)("p",null,"If you have more authentication strategies, add them in this way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"registerAuthenticationStrategy(this, NewStrategy);\n")),(0,a.kt)("h4",{id:"specifying-the-authentication-action-in-sequencets"},"Specifying the Authentication Action in ",(0,a.kt)("inlineCode",{parentName:"h4"},"sequence.ts")),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"src/sequence.ts"),", add the following imports."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {\n  AuthenticationBindings,\n  AuthenticateFn,\n} from '@loopback/authentication';\n")),(0,a.kt)("p",null,"Then add those lines in the ",(0,a.kt)("inlineCode",{parentName:"p"},"handle")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"async handle(context: RequestContext) {\n  try {\n    const {request, response} = context;\n    const route = this.findRoute(request);\n    const args = await this.parseParams(request, route);\n\n    //add authentication actions\n    await this.authenticateRequest(request);\n\n    const result = await this.invoke(route, args);\n    this.send(response, result);\n  } catch (err) {\n    if (\n      err.code === 'AUTHENTICATION_STRATEGY_NOT_FOUND' ||\n      err.code === 'USER_PROFILE_NOT_FOUND'\n    ) {\n      Object.assign(err, {statusCode: 401 /* Unauthorized */});\n    }\n    this.reject(context, err);\n    return;\n  }\n}\n")),(0,a.kt)("p",null,"This will check for authentication for every request."),(0,a.kt)("h3",{id:"authenticate-apis"},"Authenticate APIs"),(0,a.kt)("p",null,"Our Authentication and Authorization components are ready to use. Now we can apply their decorators to our REST API endpoints."),(0,a.kt)("h4",{id:"charactercontroller"},"CharacterController"),(0,a.kt)("p",null,"Open ",(0,a.kt)("inlineCode",{parentName:"p"},"src/controllers/character.controller.ts"),", add the following imports."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {\n  MyUserProfile,\n  Credential,\n  MyAuthBindings,\n  PermissionKey,\n  CredentialsRequestBody,\n  UserRequestBody,\n  UserProfileSchema,\n  JWTService,\n} from '../authorization';\nimport {authenticate,\n        TokenService,\n        AuthenticationBindings,\n} from '@loopback/authentication';\n")),(0,a.kt)("p",null,"Inject ",(0,a.kt)("inlineCode",{parentName:"p"},"TOKEN_SERVICE")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"CURRENT_USER")," in the constructor."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@inject(MyAuthBindings.TOKEN_SERVICE)\npublic jwtService: JWTService,\n@inject.getter(AuthenticationBindings.CURRENT_USER)\npublic getCurrentUser: Getter<MyUserProfile>,\n")),(0,a.kt)("p",null,"Then let's make some changes to the ",(0,a.kt)("inlineCode",{parentName:"p"},"@post /characters")," API."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@post('/characters', {\n  responses: {\n    '200': {\n      description: 'Character model instance',\n      content: {'application/json': {schema: {'x-ts-type': Character}}},\n    },\n  },\n})\nasync create(\n  @requestBody(UserRequestBody) character: Character\n): Promise<Character> {\n    character.permissions = [PermissionKey.ViewOwnUser,\n                             PermissionKey.CreateUser,\n                             PermissionKey.UpdateOwnUser,\n                             PermissionKey.DeleteOwnUser];\n    if (await this.characterRepository.exists(character.email)){\n      throw new HttpErrors.BadRequest(`This email already exists`);\n    }\n    else {\n      const savedCharacter = await this.characterRepository.create(character);\n      delete savedCharacter.password;\n      return savedCharacter;\n    }\n}\n")),(0,a.kt)("p",null,"Put ",(0,a.kt)("inlineCode",{parentName:"p"},"UserRequestBody")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"@requestBody")," decorator to specify the format of request body. That is how we validate the format of email and password fields."),(0,a.kt)("p",null,"Because this API is used to create a regular character, we will assign ",(0,a.kt)("inlineCode",{parentName:"p"},"ViewOwnUser"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"CreateUser"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateOwnUser"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"DeleteOwnUser")," permissions to the new character."),(0,a.kt)("p",null,"We also need to create an API for login."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@post('/characters/login', {\n  responses: {\n    '200': {\n      description: 'Token',\n      content: {},\n    },\n  },\n})\nasync login(\n  @requestBody(CredentialsRequestBody) credential: Credential,\n): Promise<{token: string}> {\n  const token = await this.jwtService.getToken(credential);\n  return {token};\n}\n")),(0,a.kt)("p",null,"This API will use ",(0,a.kt)("inlineCode",{parentName:"p"},"JWTService")," to verify user email and password, and then generate a JWT based on necessary credential information, like email, password and permissions."),(0,a.kt)("p",null,"The next API we need is ",(0,a.kt)("inlineCode",{parentName:"p"},"@get /characters/me"),". It will show the user current logged in."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@get('/characters/me', {\n  responses: {\n    '200': {\n      description: 'The current user profile',\n      content: {\n        'application/json': {\n          schema: UserProfileSchema,\n        },\n      },\n    },\n  },\n})\n@authenticate('jwt', {\"required\": [PermissionKey.ViewOwnUser]})\nasync printCurrentUser(\n): Promise<MyUserProfile> {\n  return await this.getCurrentUser();\n}\n")),(0,a.kt)("p",null,"We will authenticate this API with ",(0,a.kt)("inlineCode",{parentName:"p"},"@authenticate('jwt', {\"required\": [PermissionKey.ViewOwnUser]})"),". The first parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"jwt")," specify which authentication strategy you want to use for this API. If you have more than one strategy, make your choice here. The second parameter is an object which has one field ",(0,a.kt)("inlineCode",{parentName:"p"},"required")," (array of ",(0,a.kt)("inlineCode",{parentName:"p"},"PermissionKey"),"). It specifies which permissions are required to access this API. In this case, the only required permission is ",(0,a.kt)("inlineCode",{parentName:"p"},"ViewOwnUser"),". Because this API only shows current logged-in user information. You can customize permissions based on your APIs."),(0,a.kt)("p",null,"To get current logged-in user information, simply call ",(0,a.kt)("inlineCode",{parentName:"p"},"this.getCurrentUser()"),"."),(0,a.kt)("p",null,"The above three APIs show you most of the use cases. You should now have enough knowledge on how to apply LoopBack 4 authentication to your APIs."),(0,a.kt)("p",null,"Let me show you one more example before we're done."),(0,a.kt)("h4",{id:"admincontroller"},"AdminController"),(0,a.kt)("p",null,"Let's create another controller for admins. Admins should have privilege to view, update, and delete any user."),(0,a.kt)("p",null,"Here is how we create an admin."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@post('/admin', {\n  responses: {\n    '200': {\n      description: 'create admin',\n      content: {'application/json': {schema: {'x-ts-type': Character}}},\n    },\n  },\n})\nasync create(\n  @param.query.string('admin_code') admin_code: string,\n  @requestBody() character: Character,\n): Promise<Character> {\n    if(admin_code != '901029'){\n      throw new HttpErrors.Forbidden('WRONG_ADMIN_CODE');\n    }\n\n    character.permissions = [PermissionKey.ViewOwnUser,\n                             PermissionKey.CreateUser,\n                             PermissionKey.UpdateOwnUser,\n                             PermissionKey.DeleteOwnUser,\n                             PermissionKey.UpdateAnyUser,\n                             PermissionKey.ViewAnyUser,\n                             PermissionKey.DeleteAnyUser];\n    if (await this.characterRepository.exists(character.email)){\n      throw new HttpErrors.BadRequest(`This email already exists`);\n    }\n    else {\n      const savedCharacter = await this.characterRepository.create(character);\n      delete savedCharacter.password;\n      return savedCharacter;\n    }\n}\n")),(0,a.kt)("p",null,"It is very similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"@post /characters")," API. The difference is it requires an ",(0,a.kt)("inlineCode",{parentName:"p"},"admin_code")," to create an admin with three more permissions: ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateAnyUser"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ViewAnyUser"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"DeleteAnyUser"),"."),(0,a.kt)("p",null,"This is an API to show the information of all users that match the filter criteria."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@get('/admin/characters', {\n  responses: {\n    '200': {\n      description: 'Array of Character model instances',\n      content: {\n        'application/json': {\n          schema: {type: 'array', items: {'x-ts-type': Character}},\n        },\n      },\n    },\n  },\n})\n@authenticate('jwt', {\"required\": [PermissionKey.ViewAnyUser]})\nasync find(\n  @param.query.object('filter', getFilterSchemaFor(Character)) filter?: Filter,\n): Promise<Character[]> {\n  return await this.characterRepository.find(filter);\n}\n")),(0,a.kt)("p",null,"As you can see, this requires ",(0,a.kt)("inlineCode",{parentName:"p"},"ViewAnyUser")," permission."),(0,a.kt)("p",null,"You can check my controllers ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gobackhuoxing/first-web-game-lb4/tree/part4/firstgame/src/controllers"},"here")),(0,a.kt)("h3",{id:"applying-this-to-your-own-project"},"Applying This to Your Own Project"),(0,a.kt)("p",null,"In this episode, we covered how to combine your self-defined authorization strategies and services with ",(0,a.kt)("inlineCode",{parentName:"p"},"@loopback/authentication")," and how to apply it to your API."),(0,a.kt)("p",null,"You can always design your own strategies and services based on your project needs. For example, you may want to have a password hashing service, so that you don't directly save a user's raw password in the database. ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/strongloop/loopback4-example-shopping/blob/master/packages/shopping/src/services/hash.password.bcryptjs.ts"},"Here")," is an example of how to implement a password hashing service."),(0,a.kt)("h3",{id:"whats-next"},"What's Next?"),(0,a.kt)("p",null,"Next episode, we will deploy this project to cloud. In the meantime, you can learn more about LoopBack in ",(0,a.kt)("a",{parentName:"p",href:"https://strongloop.com/strongblog/tag_LoopBack.html"},"past blogs"),"."))}h.isMDXComponent=!0},6573:function(e,t,n){t.Z=n.p+"assets/images/building-online-game-pt4-auth-activity-flow-9b3ede8505a20674cb8a6a475f5728f5.png"},4323:function(e,t,n){t.Z=n.p+"assets/images/building-online-game-pt4-auth-structure-c01949ae9fb34be90ee8d350e23b8abe.png"}}]);